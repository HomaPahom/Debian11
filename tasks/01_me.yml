- name: Cleanup old/bad fstab lines for /var/log and /var/log/audit
  ansible.builtin.replace:
    path: /etc/fstab
    regexp: '^[ \t]*/var[ \t]+/var/log(?:/audit)?[ \t]+.*\n?'
    replace: ''
  notify: Mount_all

- name: "1.1.1.1 | PATCH | Ensure mounting of cramfs filesystems is disabled"
  block:
      - name: "1.1.1.1 | PATCH | Ensure mounting of cramfs filesystems is disabled | Edit modprobe config"
        ansible.builtin.lineinfile:
            dest: /etc/modprobe.d/cramfs.conf
            regexp: '^(#)?install cramfs(\\s|$)'
            line: install cramfs /bin/true
            create: true

      - name: "1.1.1.1 | PATCH | Ensure mounting of cramfs filesystems is disabled | Disable cramfs"
        community.general.modprobe:
            name: cramfs
            state: absent
        when: ansible_connection != 'docker'

      - name: "1.1.1.1 | PATCH | Ensure mounting of cramfs filesystems is disabled | blacklist cramfs"
        ansible.builtin.lineinfile:
            dest: /etc/modprobe.d/blacklist.conf
            regexp: '^blacklist cramfs'
            line: blacklist cramfs
            create: true
        notify: Update_Initramfs
  when: true
  tags:
      - level1-server
      - level1-workstation
      - automated
      - patch
      - rule_1.1.1.1
      - cramfs

- name: "1.1.1.2 | PATCH | Ensure mounting of squashfs filesystems is disabled"
  block:
      - name: "1.1.1.2 | PATCH | Ensure mounting of squashfs filesystems is disabled | Edit modprobe config"
        ansible.builtin.lineinfile:
            dest: /etc/modprobe.d/squashfs.conf
            regexp: '^(#)?install squashfs(\\s|$)'
            line: install squashfs /bin/true
            create: true

      - name: "1.1.1.2 | PATCH | Ensure mounting of squashfs filesystems is disabled | Disable squashfs"
        community.general.modprobe:
            name: squashfs
            state: absent
        when: ansible_connection != 'docker'

      - name: "1.1.1.2 | PATCH | Ensure mounting of squashfs filesystems is disabled | blacklist squashfs"
        ansible.builtin.lineinfile:
            dest: /etc/modprobe.d/blacklist.conf
            regexp: '^blacklist squashfs'
            line: blacklist squashfs
            create: true
        notify: Update_Initramfs
  tags:
      - level2-server
      - level2-workstation
      - automated
      - patch
      - rule_1.1.1.2
      - squashfs

- name: "1.1.1.3 | PATCH | Ensure mounting of udf filesystems is disabled"
  block:
      - name: "1.1.1.3 | PATCH | Ensure mounting of udf filesystems is disabled | Edit modprobe config"
        ansible.builtin.lineinfile:
            dest: /etc/modprobe.d/udf.conf
            regexp: '^(#)?install udf(\\s|$)'
            line: install udf /bin/true
            create: true

      - name: "1.1.1.3 | PATCH | Ensure mounting of udf filesystems is disabled | Disable udf"
        community.general.modprobe:
            name: udf
            state: absent
        when: ansible_connection != 'docker'

      - name: "1.1.1.3 | PATCH | Ensure mounting of udf filesystems is disabled | blacklist udf"
        ansible.builtin.lineinfile:
            dest: /etc/modprobe.d/blacklist.conf
            regexp: '^blacklist udf'
            line: blacklist udf
            create: true
        notify: Update_Initramfs
  tags:
      - level2-server
      - level2-workstation
      - automated
      - patch
      - rule_1.1.1.3
      - udf

- name: "1.1.1.4 | PATCH | Ensure hfsplus kernel module is not available"
  block:
      - name: "1.1.1.4 | PATCH | Ensure hfsplus kernel module is not available | Edit modprobe config"
        ansible.builtin.lineinfile:
            dest: /etc/modprobe.d/hfsplus.conf
            regexp: '^(#)?install hfsplus(\\s|$)'
            line: install hfsplus /bin/true
            create: true

      - name: "1.1.1.4 | PATCH | Ensure hfsplus kernel module is not available | Disable hfsplus"
        community.general.modprobe:
            name: hfsplus
            state: absent
        when: ansible_connection != 'docker'

      - name: "1.1.1.4 | PATCH | Ensure hfsplus kernel module is not available | blacklist hfsplus"
        ansible.builtin.lineinfile:
            dest: /etc/modprobe.d/blacklist.conf
            regexp: '^blacklist hfsplus'
            line: blacklist hfsplus
            create: true
        notify: Update_Initramfs
  tags:
      - level1-server
      - level1-workstation
      - automated
      - patch
      - rule_1.1.1.4
      - hfsplus

- name: "1.1.1.5 | PATCH | Ensure jffs2 kernel module is not available"
  block:
      - name: "1.1.1.5 | PATCH | Ensure jffs2 kernel module is not available | Edit modprobe config"
        ansible.builtin.lineinfile:
            dest: /etc/modprobe.d/jffs2.conf
            regexp: '^(#)?install jffs2(\\s|$)'
            line: install jffs2 /bin/true
            create: true

      - name: "1.1.1.5 | PATCH | Ensure jffs2 kernel module is not available | Disable jffs2"
        community.general.modprobe:
            name: jffs2
            state: absent
        when: ansible_connection != 'docker'

      - name: "1.1.1.5 | PATCH | Ensure jffs2 kernel module is not available | blacklist jffs2"
        ansible.builtin.lineinfile:
            dest: /etc/modprobe.d/blacklist.conf
            regexp: '^blacklist jffs2'
            line: blacklist jffs2
            create: true
        notify: Update_Initramfs
  tags:
      - level1-server
      - level1-workstation
      - automated
      - patch
      - rule_1.1.1.5
      - jffs2

- name: "1.1.1.7 | PATCH | Ensure squashfs kernel module is not available"
  block:
      - name: "1.1.1.7 | PATCH | Ensure squashfs kernel module is not available | Edit modprobe config"
        ansible.builtin.lineinfile:
            dest: /etc/modprobe.d/squashfs.conf
            regexp: '^(#)?install squashfs(\\s|$)'
            line: install squashfs /bin/true
            create: true

      - name: "1.1.1.7 | PATCH | Ensure squashfs kernel module is not available | Disable squashfs"
        community.general.modprobe:
            name: squashfs
            state: absent
        when: ansible_connection != 'docker'

      - name: "1.1.1.7 | PATCH | Ensure squashfs kernel module is not available | blacklist squashfs"
        ansible.builtin.lineinfile:
            dest: /etc/modprobe.d/blacklist.conf
            regexp: '^blacklist squashfs'
            line: blacklist squashfs
            create: true
        notify: Update_Initramfs
  tags:
      - level2-server
      - level2-workstation
      - automated
      - patch
      - rule_1.1.1.7
      - squashfs

- name: "1.1.1.8 | PATCH | Ensure udf kernel module is not available"
  block:
      - name: "1.1.1.8 | PATCH | Ensure udf kernel module is not available | Edit modprobe config"
        ansible.builtin.lineinfile:
            dest: /etc/modprobe.d/udf.conf
            regexp: '^(#)?install udf(\\s|$)'
            line: install udf /bin/true
            create: true

      - name: "1.1.1.8 | PATCH | Ensure udf kernel module is not available | Disable udf"
        community.general.modprobe:
            name: udf
            state: absent
        when: ansible_connection != 'docker'

      - name: "1.1.1.8 | PATCH | Ensure udf kernel module is not available | blacklist udf"
        ansible.builtin.lineinfile:
            dest: /etc/modprobe.d/blacklist.conf
            regexp: '^blacklist udf'
            line: blacklist udf
            create: true
        notify: Update_Initramfs
  when:
      - not azure_vm_detected | default(false)
  tags:
      - level2-server
      - level2-workstation
      - automated
      - patch
      - rule_1.1.1.8
      - udf

- name: "1.1.1.9 | PATCH | Ensure usb-storage kernel module is not available"
  block:
      - name: "1.1.1.9 | PATCH | Ensure usb-storage kernel module is not available | Edit modprobe config"
        ansible.builtin.lineinfile:
            dest: /etc/modprobe.d/usb-storage.conf
            regexp: '^(#)?install usb-storage(\\s|$)'
            line: install usb-storage /bin/true
            create: true

      - name: "1.1.1.9 | PATCH | Ensure usb-storage kernel module is not available | Disable usb-storage"
        community.general.modprobe:
            name: usb-storage
            state: absent
        when: ansible_connection != 'docker'

      - name: "1.1.1.9 | PATCH | Ensure usb-storage kernel module is not available | blacklist usb-storage"
        ansible.builtin.lineinfile:
            dest: /etc/modprobe.d/blacklist.conf
            regexp: '^blacklist usb-storage'
            line: blacklist usb-storage
            create: true
        notify: Update_Initramfs
  tags:
      - level1-server
      - level2-workstation
      - stig
      - automated
      - patch
      - rule_1.1.1.9
      - usb-storage

- name: "1.1.1.12 | PATCH | Ensure sticky bit is set on all world-writable directories"
  block:
    - name: "1.1.1.12 | PATCH | Find world-writable directories without sticky bit"
      ansible.builtin.shell: |
        set -o pipefail
        df --local -P | awk 'NR>1 {print $6}' \
        | xargs -r -I '{}' find '{}' -xdev -type d \( -perm -0002 -a ! -perm -1000 \) 2>/dev/null || true
      args:
        executable: /bin/bash
      register: world_writable_dirs
      changed_when: false

    - name: "1.1.1.12 | PATCH | Set sticky bit on all world-writable directories"
      ansible.builtin.command: chmod a+t "{{ item }}"
      loop: "{{ world_writable_dirs.stdout_lines }}"
      when: world_writable_dirs.stdout | length > 0
      loop_control:
        label: "{{ item }}"
  when: debian11cis_rule_1_1_1_12 | default(true)
  tags:
    - level1-server
    - level1-workstation
    - stig
    - automated
    - patch
    - rule_1.1.1.12
    - stickybit

- name: "1.1.2.1.2 | PATCH | Ensure /tmp has nodev (and other secure opts)"
  block:
    - name: Get /tmp mount info (if any)
      command: findmnt -nro SOURCE,FSTYPE /tmp
      register: tmp_info
      changed_when: false
      failed_when: false

    - name: Extract current /tmp src/fstype (or defaults)
      set_fact:
        tmp_src: "{{ (tmp_info.stdout.split(' ')[0]) if tmp_info.rc == 0 else 'tmpfs' }}"
        tmp_fstype: "{{ (tmp_info.stdout.split(' ')[1]) if tmp_info.rc == 0 else 'tmpfs' }}"
        tmp_opts: "defaults,rw,noexec,nosuid,nodev,relatime"

    - name: Ensure fstab has desired options for existing /tmp
      when: tmp_info.rc == 0
      ansible.posix.mount:
        path: /tmp
        src: "{{ tmp_src }}"
        fstype: "{{ tmp_fstype }}"
        opts: "{{ tmp_opts }}"
        state: present

    - name: Remount /tmp with desired options
      when: tmp_info.rc == 0
      ansible.posix.mount:
        path: /tmp
        src: "{{ tmp_src }}"
        fstype: "{{ tmp_fstype }}"
        opts: "{{ tmp_opts }}"
        state: mounted

    - name: Ensure /tmp tmpfs entry in fstab
      when: tmp_info.rc != 0
      ansible.posix.mount:
        path: /tmp
        src: tmpfs
        fstype: tmpfs
        opts: "{{ tmp_opts }}"
        state: present

    - name: Mount /tmp as tmpfs with secure options
      when: tmp_info.rc != 0
      ansible.posix.mount:
        path: /tmp
        src: tmpfs
        fstype: tmpfs
        opts: "{{ tmp_opts }}"
        state: mounted
  tags:
    - level1-server
    - level1-workstation
    - automated
    - patch
    - rule_1.1.2.1.2
    - tmp
    - nodev

- name: "1.1.2.1.3 | PATCH | Ensure nosuid option set on /tmp partition"
  block:
      - name: "1.1.2.1.3 | PATCH | Check if /tmp is a separate partition"
        ansible.builtin.command: findmnt -kn /tmp
        register: tmp_mount
        changed_when: false
        failed_when: false

      - name: "1.1.2.1.3 | PATCH | Ensure nosuid option is set on /tmp partition in /etc/fstab"
        ansible.builtin.replace:
            path: /etc/fstab
            regexp: '^(\S+\s+/tmp\s+\S+\s+)([^#\n]*)'
            replace: '\1\2,nosuid'
        when: tmp_mount.rc == 0
        notify: Remount_tmp

      - name: "1.1.2.1.3 | PATCH | Ensure /tmp is mounted with nosuid option"
        ansible.posix.mount:
            path: /tmp
            src: "{{ (ansible_mounts | selectattr('mount', 'equalto', '/tmp') | map(attribute='device') | list | first) | default('tmpfs') }}"
            fstype: "{{ (ansible_mounts | selectattr('mount', 'equalto', '/tmp') | map(attribute='fstype') | list | first) | default('tmpfs') }}"
            opts: defaults,rw,nosuid,nodev,noexec,relatime
            state: mounted
        when: tmp_mount.rc == 0
  tags:
      - level1-server
      - level1-workstation
      - automated
      - patch
      - rule_1.1.2.1.3
      - tmp
      - nosuid

- name: "1.1.2.1.4 | PATCH | Ensure noexec option set on /tmp partition"
  block:
      - name: "1.1.2.1.4 | PATCH | Check if /tmp is a separate partition"
        ansible.builtin.command: findmnt -kn /tmp
        register: tmp_mount
        changed_when: false
        failed_when: false

      - name: "1.1.2.1.4 | PATCH | Ensure noexec option is set on /tmp partition in /etc/fstab"
        ansible.builtin.replace:
            path: /etc/fstab
            regexp: '^(\S+\s+/tmp\s+\S+\s+)([^#\n]*)'
            replace: '\1\2,noexec'
        when: tmp_mount.rc == 0
        notify: Remount_tmp

      - name: "1.1.2.1.4 | PATCH | Ensure /tmp is mounted with noexec option"
        ansible.posix.mount:
            path: /tmp
            src: "{{ (ansible_mounts | selectattr('mount', 'equalto', '/tmp') | map(attribute='device') | list | first) | default('tmpfs') }}"
            fstype: "{{ (ansible_mounts | selectattr('mount', 'equalto', '/tmp') | map(attribute='fstype') | list | first) | default('tmpfs') }}"
            opts: defaults,rw,nosuid,nodev,noexec,relatime
            state: mounted
        when: tmp_mount.rc == 0
  tags:
      - level1-server
      - level1-workstation
      - automated
      - patch
      - rule_1.1.2.1.4
      - tmp
      - noexec

- name: "1.1.2.2.1 | PATCH | Ensure /dev/shm is a separate partition"
  block:
      - name: "1.1.2.2.1 | PATCH | Check if /dev/shm is mounted as a separate partition"
        ansible.builtin.command: findmnt -kn /dev/shm
        register: dev_shm_mount
        changed_when: false
        failed_when: false

      - name: "1.1.2.2.1 | PATCH | Configure /dev/shm as a separate tmpfs partition in /etc/fstab"
        ansible.builtin.lineinfile:
            path: /etc/fstab
            regexp: '^tmpfs\s+/dev/shm'
            line: 'tmpfs /dev/shm tmpfs defaults,rw,nosuid,nodev,noexec,relatime,size=2G 0 0'
            create: true
        when: dev_shm_mount.rc != 0
        notify: Mount_dev_shm

      - name: "1.1.2.2.1 | PATCH | Mount /dev/shm if not already mounted"
        ansible.posix.mount:
            path: /dev/shm
            src: tmpfs
            fstype: tmpfs
            opts: defaults,rw,nosuid,nodev,noexec,relatime,size=2G
            state: mounted
        when: dev_shm_mount.rc != 0
  tags:
      - level1-server
      - level1-workstation
      - automated
      - patch
      - rule_1.1.2.2.1
      - devshm

- name: "1.1.2.2.2 | PATCH | Ensure nodev option set on /dev/shm partition"
  block:
      - name: "1.1.2.2.2 | PATCH | Check if /dev/shm is a separate partition"
        ansible.builtin.command: findmnt -kn /dev/shm
        register: dev_shm_mount
        changed_when: false
        failed_when: false

      - name: "1.1.2.2.2 | PATCH | Ensure nodev option is set on /dev/shm partition in /etc/fstab"
        ansible.builtin.replace:
            path: /etc/fstab
            regexp: '^(\S+\s+/dev/shm\s+\S+\s+)([^#\n]*)'
            replace: '\1\2,nodev'
        when: dev_shm_mount.rc == 0
        notify: Remount_dev_shm

      - name: "1.1.2.2.2 | PATCH | Ensure /dev/shm is mounted with nodev option"
        ansible.posix.mount:
            path: /dev/shm
            src: tmpfs
            fstype: tmpfs
            opts: defaults,rw,nosuid,nodev,noexec,relatime
            state: mounted
        when: dev_shm_mount.rc == 0
  tags:
      - level1-server
      - level1-workstation
      - automated
      - patch
      - rule_1.1.2.2.2
      - devshm
      - nodev

- name: "1.1.2.2.3 | PATCH | Ensure nosuid option set on /dev/shm partition"
  block:
      - name: "1.1.2.2.3 | PATCH | Check if /dev/shm is a separate partition"
        ansible.builtin.command: findmnt -kn /dev/shm
        register: dev_shm_mount
        changed_when: false
        failed_when: false

      - name: "1.1.2.2.3 | PATCH | Ensure nosuid option is set on /dev/shm partition in /etc/fstab"
        ansible.builtin.replace:
            path: /etc/fstab
            regexp: '^(\S+\s+/dev/shm\s+\S+\s+)([^#\n]*)'
            replace: '\1\2,nosuid'
        when: dev_shm_mount.rc == 0
        notify: Remount_dev_shm

      - name: "1.1.2.2.3 | PATCH | Ensure /dev/shm is mounted with nosuid option"
        ansible.posix.mount:
            path: /dev/shm
            src: tmpfs
            fstype: tmpfs
            opts: defaults,rw,nosuid,nodev,noexec,relatime
            state: mounted
        when: dev_shm_mount.rc == 0
  tags:
      - level1-server
      - level1-workstation
      - automated
      - patch
      - rule_1.1.2.2.3
      - devshm
      - nosuid

- name: "1.1.2.2.4 | PATCH | Ensure noexec option set on /dev/shm partition"
  block:
      - name: "1.1.2.2.4 | PATCH | Check if /dev/shm is a separate partition"
        ansible.builtin.command: findmnt -kn /dev/shm
        register: dev_shm_mount
        changed_when: false
        failed_when: false

      - name: "1.1.2.2.4 | PATCH | Ensure noexec option is set on /dev/shm partition in /etc/fstab"
        ansible.builtin.replace:
            path: /etc/fstab
            regexp: '^(\S+\s+/dev/shm\s+\S+\s+)([^#\n]*)'
            replace: '\1\2,noexec'
        when: dev_shm_mount.rc == 0
        notify: Remount_dev_shm

      - name: "1.1.2.2.4 | PATCH | Ensure /dev/shm is mounted with noexec option"
        ansible.posix.mount:
            path: /dev/shm
            src: tmpfs
            fstype: tmpfs
            opts: defaults,rw,nosuid,nodev,noexec,relatime
            state: mounted
        when: dev_shm_mount.rc == 0
  tags:
      - level1-server
      - level1-workstation
      - automated
      - patch
      - rule_1.1.2.2.4
      - devshm
      - noexec

- name: "1.1.2.3.2 | PATCH | Ensure nodev option set on /home partition"
  block:
    - name: "Check if /home is a separate partition"
      ansible.builtin.command: findmnt -kn /home
      register: home_mount
      changed_when: false
      failed_when: false

    - name: "Ensure /home directory exists"
      ansible.builtin.file:
        path: /home
        state: directory
        owner: root
        group: root
        mode: '0755'

    - name: "Ensure nodev option set on /home partition (if it exists)"
      ansible.posix.mount:
        path: /home
        src: "{{ (ansible_mounts | selectattr('mount', 'equalto', '/home') | map(attribute='device') | list | first) | default('none') }}"
        fstype: "{{ (ansible_mounts | selectattr('mount', 'equalto', '/home') | map(attribute='fstype') | list | first) | default('ext4') }}"
        opts: nodev,nosuid,relatime
        state: mounted
      when: home_mount.rc == 0

    - name: "Ensure /home entry exists in /etc/fstab (if partition exists)"
      ansible.builtin.lineinfile:
        path: /etc/fstab
        regexp: '^\S+\s+/home\s+'
        line: "{{ (ansible_mounts | selectattr('mount', 'equalto', '/home') | map(attribute='device') | list | first) | default('UUID=none') }} /home ext4 nodev,nosuid,relatime 0 2"
        create: yes
      when: home_mount.rc == 0
  tags:
    - level1-server
    - level1-workstation
    - patch
    - rule_1.1.2.3.2
    - home
    - nodev

- name: "1.1.2.3.3 | PATCH | Ensure nosuid option set on /home partition"
  block:
    - name: "Check if /home is a separate partition"
      ansible.builtin.command: findmnt -kn /home
      register: home_mount
      changed_when: false
      failed_when: false

    - name: "Ensure /home is mounted with nosuid,nodev (if separate partition exists)"
      ansible.posix.mount:
        path: /home
        src: "{{ (ansible_mounts | selectattr('mount', 'equalto', '/home') | map(attribute='device') | list | first) | default('none') }}"
        fstype: "{{ (ansible_mounts | selectattr('mount', 'equalto', '/home') | map(attribute='fstype') | list | first) | default('ext4') }}"
        opts: nodev,nosuid,relatime
        state: mounted
      when: home_mount.rc == 0

    - name: "Ensure /home entry exists in /etc/fstab (if separate partition exists)"
      ansible.builtin.lineinfile:
        path: /etc/fstab
        regexp: '^\S+\s+/home\s+'
        line: "{{ (ansible_mounts | selectattr('mount', 'equalto', '/home') | map(attribute='device') | list | first) | default('UUID=none') }} /home ext4 nodev,nosuid,relatime 0 2"
        create: yes
      when: home_mount.rc == 0
  tags:
    - level1-server
    - level1-workstation
    - patch
    - rule_1.1.2.3.3
    - home
    - nosuid

- name: "1.1.2.5.1 | PATCH | Ensure separate partition exists for /var/tmp (bind if missing)"
  block:
    - name: "Check current /var/tmp mount"
      command: findmnt -nro SOURCE,FSTYPE /var/tmp
      register: var_tmp_info
      changed_when: false
      failed_when: false

    - name: "Warn if /var/tmp is not a separate mount"
      debug:
        msg: >
          [CIS WARNING] /var/tmp is not a separate partition. Will configure bind-mount to comply.
      when: var_tmp_info.rc != 0

    - name: "Prepare /var/tmp (dir & mode)"
      file:
        path: /var/tmp
        state: directory
        owner: root
        group: root
        mode: '1777'

    # ВАЖНО: убрать ранее добавленную конфликтную строку
    - name: "Cleanup bad duplicate /var/tmp fstab line (remount artifact)"
      ansible.builtin.replace:
        path: /etc/fstab
        regexp: '^[ \t]*none[ \t]+/var/tmp[ \t]+none[ \t]+remount,bind,nodev,nosuid,noexec[ \t]+0[ \t]+0[ \t]*\n?'
        replace: ''
        backup: yes

    # Правильная единичная запись в fstab через модуль mount
    - name: "Ensure /var/tmp bind entry exists in fstab (single, correct line)"
      ansible.posix.mount:
        path: /var/tmp
        src: /tmp
        fstype: none
        opts: bind,nodev,nosuid,noexec
        state: present
      when: var_tmp_info.rc != 0

    - name: "Ensure /var/tmp is mounted with secure options"
      ansible.posix.mount:
        path: /var/tmp
        src: /tmp
        fstype: none
        opts: bind,nodev,nosuid,noexec
        state: mounted
      when: var_tmp_info.rc != 0
  when: debian11cis_rule_1_1_2_5_1 | default(true)
  tags:
    - level2-server
    - level2-workstation
    - manual
    - patch
    - rule_1.1.2.5.1
    - vartmp
    - partition

- name: "1.1.2.5.2-5.4 | PATCH | Ensure nodev,nosuid,noexec on /var/tmp"
  block:
    - name: "Re-check /var/tmp mount source"
      command: findmnt -nro SOURCE /var/tmp
      register: var_tmp_src
      changed_when: false
      failed_when: false

    - name: "Choose mount options depending on type (bind vs real FS)"
      set_fact:
        var_tmp_opts: >-
          {{ 'bind,nodev,nosuid,noexec'
             if (var_tmp_src.rc == 0 and var_tmp_src.stdout | trim == '/tmp')
             else 'defaults,rw,nosuid,nodev,noexec,relatime' }}

    - name: "Ensure fstab entry for /var/tmp present with proper opts"
      ansible.posix.mount:
        path: /var/tmp
        src: "{{ '/tmp' if (var_tmp_src.rc == 0 and var_tmp_src.stdout | trim == '/tmp') else (ansible_mounts | selectattr('mount','equalto','/var/tmp') | map(attribute='device') | list | first) | default('/tmp') }}"
        fstype: "{{ 'none' if (var_tmp_src.rc == 0 and var_tmp_src.stdout | trim == '/tmp') else (ansible_mounts | selectattr('mount','equalto','/var/tmp') | map(attribute='fstype') | list | first) | default('ext4') }}"
        opts: "{{ var_tmp_opts }}"
        state: present

    - name: "Ensure /var/tmp is mounted with secure options"
      ansible.posix.mount:
        path: /var/tmp
        src: "{{ '/tmp' if (var_tmp_src.rc == 0 and var_tmp_src.stdout | trim == '/tmp') else (ansible_mounts | selectattr('mount','equalto','/var/tmp') | map(attribute='device') | list | first) | default('/tmp') }}"
        fstype: "{{ 'none' if (var_tmp_src.rc == 0 and var_tmp_src.stdout | trim == '/tmp') else (ansible_mounts | selectattr('mount','equalto','/var/tmp') | map(attribute='fstype') | list | first) | default('ext4') }}"
        opts: "{{ var_tmp_opts }}"
        state: mounted
  when:
    - debian11cis_rule_1_1_2_5_2 | default(true)
    - debian11cis_rule_1_1_2_5_3 | default(true)
    - debian11cis_rule_1_1_2_5_4 | default(true)
  tags:
    - level1-server
    - level1-workstation
    - automated
    - patch
    - rule_1.1.2.5.2
    - rule_1.1.2.5.3
    - rule_1.1.2.5.4
    - vartmp
    - nodev
    - nosuid
    - noexec

- name: "1.1.2.6.1 | PATCH | Ensure separate partition exists for /var/log"
  block:
    - name: Check if /var/log is a separate partition
      ansible.builtin.command: findmnt -kn /var/log
      register: var_log_mount
      changed_when: false
      failed_when: false

    - name: Ensure /var/log directory exists
      ansible.builtin.file:
        path: /var/log
        state: directory
        owner: root
        group: root
        mode: '0755'

    # ВАЖНО: self-bind, src=/var/log (не /var)
    - name: Create bind mount for /var/log if not a separate partition
      ansible.posix.mount:
        path: /var/log
        src: /var/log
        fstype: none
        opts: bind
        state: mounted
      when: var_log_mount.rc != 0

    # Для bind безопасные опции задаём ремонтом
    - name: Remount /var/log with secure options
      ansible.builtin.command: mount -o remount,bind,nodev,nosuid,noexec /var/log
      changed_when: true

    # В /etc/fstab — две строки для bind (обычная практика)
    - name: Ensure /var/log entries exist in /etc/fstab
      ansible.builtin.blockinfile:
        path: /etc/fstab
        marker: "# {mark} CIS /var/log"
        block: |
          /var/log  /var/log  none  bind                              0 0
          /var/log  /var/log  none  remount,bind,nodev,nosuid,noexec  0 0
  tags:
    - level2-server
    - level2-workstation
    - patch
    - rule_1.1.2.6.1
    - varlog
    - partition

- name: "1.1.2.6.2 | PATCH | Ensure nodev option set on /var/log partition"
  block:
    - name: "1.1.2.6.2 | PATCH | Ensure nodev option is active on /var/log"
      ansible.posix.mount:
        path: /var/log
        src: /var/log 
        fstype: none
        opts: bind,nodev,nosuid,noexec,relatime
        state: mounted
      when: var_log_mount.rc != 0
  tags:
    - level1-server
    - level1-workstation
    - patch
    - rule_1.1.2.6.2
    - varlog
    - nodev

- name: "1.1.2.6.3 | PATCH | Ensure nosuid option set on /var/log partition"
  block:
    - name: "1.1.2.6.3 | PATCH | Ensure nosuid option is active on /var/log"
      ansible.posix.mount:
        path: /var/log
        src: /var/log 
        fstype: none
        opts: bind,nodev,nosuid,noexec,relatime
        state: mounted
      when: var_log_mount.rc != 0
  tags:
    - level1-server
    - level1-workstation
    - patch
    - rule_1.1.2.6.3
    - varlog
    - nosuid

- name: "1.1.2.6.4 | PATCH | Ensure noexec option set on /var/log partition"
  block:
    - name: "1.1.2.6.4 | PATCH | Ensure noexec option is active on /var/log"
      ansible.posix.mount:
        path: /var/log
        src: /var/log 
        fstype: none
        opts: bind,nodev,nosuid,noexec,relatime
        state: mounted
      when: var_log_mount.rc != 0
  tags:
    - level1-server
    - level1-workstation
    - patch
    - rule_1.1.2.6.4
    - varlog
    - noexec

- name: "1.1.2.7.1 | PATCH | Ensure separate partition exists for /var/log/audit"
  block:
    - name: Check if /var/log/audit is a separate partition
      ansible.builtin.command: findmnt -kn /var/log/audit
      register: var_log_audit_mount
      changed_when: false
      failed_when: false

    - name: Ensure /var/log/audit directory exists
      ansible.builtin.file:
        path: /var/log/audit
        state: directory
        owner: root
        group: root
        mode: '0750'

    # ВАЖНО: self-bind, src=/var/log/audit (не /var/log)
    - name: Create bind mount for /var/log/audit if not a separate partition
      ansible.posix.mount:
        path: /var/log/audit
        src: /var/log/audit
        fstype: none
        opts: bind
        state: mounted
      when: var_log_audit_mount.rc != 0

    - name: Remount /var/log/audit with secure options
      ansible.builtin.command: mount -o remount,bind,nodev,nosuid,noexec /var/log/audit
      changed_when: true

    - name: Ensure /var/log/audit entries exist in /etc/fstab
      ansible.builtin.blockinfile:
        path: /etc/fstab
        marker: "# {mark} CIS /var/log/audit"
        block: |
          /var/log/audit  /var/log/audit  none  bind                              0 0
          /var/log/audit  /var/log/audit  none  remount,bind,nodev,nosuid,noexec  0 0
  tags:
    - level2-server
    - level2-workstation
    - patch
    - rule_1.1.2.7.1
    - varlogaudit
    - partition

- name: "1.1.2.7.2 | PATCH | Ensure nodev option set on /var/log/audit partition"
  block:
    - name: "1.1.2.7.2 | PATCH | Ensure nodev option is active on /var/log/audit"
      ansible.posix.mount:
        path: /var/log/audit
        src: /var/log/audit
        fstype: none
        opts: bind,nodev,nosuid,noexec,relatime
        state: mounted
  when: var_log_audit_mount.rc != 0 
  tags:
    - level1-server
    - level1-workstation
    - patch
    - rule_1.1.2.7.2
    - varlogaudit
    - nodev

- name: "1.1.2.7.3 | PATCH | Ensure nosuid option set on /var/log/audit partition"
  block:
    - name: "1.1.2.7.3 | PATCH | Ensure nosuid option is active on /var/log/audit"
      ansible.posix.mount:
        path: /var/log/audit
        src: /var/log/audit
        fstype: none
        opts: bind,nodev,nosuid,noexec,relatime
        state: mounted
  when: var_log_audit_mount.rc != 0 
  tags:
    - level1-server
    - level1-workstation
    - patch
    - rule_1.1.2.7.3
    - varlogaudit
    - nosuid

- name: "1.1.2.7.4 | PATCH | Ensure noexec option set on /var/log/audit partition"
  block:
    - name: "1.1.2.7.4 | PATCH | Ensure noexec option is active on /var/log/audit"
      ansible.posix.mount:
        path: /var/log/audit
        src: /var/log/audit
        fstype: none
        opts: bind,nodev,nosuid,noexec,relatime
        state: mounted
  when: var_log_audit_mount.rc != 0 
  tags:
    - level1-server
    - level1-workstation
    - patch
    - rule_1.1.2.7.4
    - varlogaudit
    - noexec

- name: "1.2.1 | AUDIT | Ensure package manager repositories are configured"
  block:
      - name: "1.2.1 | AUDIT | Ensure package manager repositories are configured | Get repositories"
        ansible.builtin.shell: apt-cache policy
        changed_when: false
        failed_when: false
        register: apt_repos

      - name: "1.2.1 | AUDIT | Ensure package manager repositories are configured | Message out repository configs"
        ansible.builtin.debug:
            msg:
                - "Warning!! Below are the apt package repositories configured on the system."
                - "Please review them to make sure they conform to your site's policies."
                - "{{ apt_repos.stdout_lines }}"
  when: ansible_os_family == "Debian"
  tags:
      - level1-server
      - level1-workstation
      - audit
      - rule_1.2.1
      - apt

- name: "1.2.2 | AUDIT | Ensure GPG keys are configured"
  block:
      - name: "1.2.2 | AUDIT | Ensure GPG keys are configured | Get apt GPG keys"
        ansible.builtin.shell: apt-key list
        changed_when: false
        failed_when: false
        register: apt_gpg_keys

      - name: "1.2.2 | AUDIT | Ensure GPG keys are configured | Message out apt GPG keys"
        ansible.builtin.debug:
            msg:
                - "Warning!! Below are the apt GPG keys configured on the system."
                - "Please review them to make sure they are configured according to site policy."
                - "{{ apt_gpg_keys.stdout_lines }}"
  when: ansible_os_family == "Debian"
  tags:
      - level1-server
      - level1-workstation
      - audit
      - rule_1.2.2
      - gpg
      - keys

- name: "1.2.3 | PATCH | Ensure package manager repositories are updated"
  ansible.builtin.apt:
      update_cache: yes
  when:
      - ansible_os_family == "Debian"
  tags:
      - level1-server
      - level1-workstation
      - automated
      - patch
      - rule_1.2.3
      - apt
      - update

- name: "1.2.4 | PATCH | Ensure package manager installs only from approved repositories"
  block:
      - name: "1.2.4 | PATCH | Check repository origin for installed packages"
        ansible.builtin.shell: apt-cache policy | grep "http" | grep -v "security.debian.org"
        changed_when: false
        failed_when: false
        register: repo_origin_check

      - name: "1.2.4 | PATCH | Display non-approved repositories"
        ansible.builtin.debug:
            msg:
                - "The following repositories are NOT from approved sources:"
                - "{{ repo_origin_check.stdout_lines | default(['None found']) }}"
  when: ansible_os_family == "Debian"
  tags:
      - level1-server
      - level1-workstation
      - manual
      - patch
      - rule_1.2.4
      - repositories

- name: "1.2.3 | AUDIT | Ensure GPG keys are configured"
  block:
      - name: "1.2.3 | AUDIT | Ensure GPG keys are configured | Get APT GPG keys"
        ansible.builtin.shell: apt-key list
        changed_when: false
        failed_when: false
        register: apt_gpg_keys

      - name: "1.2.3 | AUDIT | Ensure GPG keys are configured | Display configured GPG keys"
        ansible.builtin.debug:
            msg:
                - "Below are the GPG keys currently configured for APT."
                - "Please verify that they are configured according to your site policy."
                - "{{ apt_gpg_keys.stdout_lines }}"
  when: ansible_os_family == "Debian"
  tags:
      - level1-server
      - level1-workstation
      - manual
      - audit
      - rule_1.2.3
      - apt
      - gpg
      - keys

- name: "1.2.4 | PATCH | Ensure apt is configured to prevent installation without verification of a recognized and approved digital signature"
  block:
      - name: "1.2.4 | PATCH | Check if AllowUnauthenticated is set in apt configuration"
        ansible.builtin.shell: grep -r "AllowUnauthenticated" /etc/apt/apt.conf.d/ || true
        changed_when: false
        failed_when: false
        register: apt_allowunauth

      - name: "1.2.4 | PATCH | Display current AllowUnauthenticated settings"
        ansible.builtin.debug:
            msg:
                - "Below are the current AllowUnauthenticated configurations found:"
                - "{{ apt_allowunauth.stdout_lines | default(['No AllowUnauthenticated entries found.']) }}"

      - name: "1.2.4 | PATCH | Ensure AllowUnauthenticated is set to false in apt configuration"
        ansible.builtin.replace:
            path: "{{ item }}"
            regexp: '^(.*AllowUnauthenticated\s+)"true"(.*)$'
            replace: '\1"false"\2'
        with_fileglob:
            - "/etc/apt/apt.conf.d/*"
        notify: Update_apt_cache

      - name: "1.2.4 | PATCH | Ensure AllowUnauthenticated directive exists if missing"
        ansible.builtin.lineinfile:
            path: "/etc/apt/apt.conf.d/99-unauthenticated.conf"
            line: 'APT::Get::AllowUnauthenticated "false";'
            create: yes
  when: ansible_os_family == "Debian"
  tags:
      - stig
      - level1-server
      - level1-workstation
      - automated
      - patch
      - rule_1.2.4
      - apt
      - signature
      - gpg

- name: "1.2.5 | PATCH | Ensure the Advance Package Tool removes all software components after updated versions have been installed"
  block:
      - name: "1.2.5 | PATCH | Check current APT unattended-upgrades configuration for removal settings"
        ansible.builtin.shell: grep -i remove-unused /etc/apt/apt.conf.d/50unattended-upgrades || true
        changed_when: false
        failed_when: false
        register: apt_remove_unused_check

      - name: "1.2.5 | PATCH | Display current remove-unused settings"
        ansible.builtin.debug:
            msg:
                - "Current configuration in /etc/apt/apt.conf.d/50unattended-upgrades:"
                - "{{ apt_remove_unused_check.stdout_lines | default(['No remove-unused entries found.']) }}"

      - name: "1.2.5 | PATCH | Ensure Remove-Unused-Dependencies and Remove-Unused-Kernel-Packages are enabled"
        ansible.builtin.blockinfile:
            path: /etc/apt/apt.conf.d/50unattended-upgrades
            block: |
                Unattended-Upgrade::Remove-Unused-Dependencies "true";
                Unattended-Upgrade::Remove-Unused-Kernel-Packages "true";
            marker: "# {mark} CIS 1.2.5 Ensure automatic removal of old packages"
            create: yes
  when: ansible_os_family == "Debian"
  tags:
      - stig
      - level1-server
      - level1-workstation
      - automated
      - patch
      - rule_1.2.5
      - apt
      - unattended-upgrades
      - cleanup

#- name: "1.3.1 | PATCH | Ensure AIDE is installed"
  #block:
      #- name: "1.3.1 | PATCH | Install AIDE packages"
        #ansible.builtin.package:
            #name:
                #- aide
                #- aide-common
            #state: present
            #update_cache: true

      #- name: "1.3.1 | PATCH | Initialize AIDE database"
        #ansible.builtin.shell: |
            #aideinit && mv /var/lib/aide/aide.db.new /var/lib/aide/aide.db
        #args:
            #creates: /var/lib/aide/aide.db
        #changed_when: false
        #failed_when: false
        #when: not ansible_check_mode
  #when: ansible_os_family == "Debian"
  #tags:
      #- level1-server
      #- level1-workstation
      #- automated
      #- patch
      #- rule_1.3.1
      #- aide

#- name: "1.3.2 | PATCH | Ensure filesystem integrity is regularly checked"
  #block:
      #- name: "1.3.2 | PATCH | Schedule AIDE integrity check"
        #ansible.builtin.cron:
            #name: "Run AIDE integrity check"
            #user: root
            #minute: "0"
            #hour: "5"
            #day: "*"
            #month: "*"
            #weekday: "*"
            #job: "/usr/bin/aide.wrapper --check"
  #when: ansible_os_family == "Debian"
  #tags:
      #- level1-server
      #- level1-workstation
      #- automated
      #- patch
      #- rule_1.3.2
      #- aide
      #- cron

- name: "1.4.1 | PATCH | Ensure bootloader password is set"
  block:
      - name: "1.4.1 | PATCH | Ensure bootloader password is set | Create GRUB user configuration"
        ansible.builtin.copy:
            dest: /etc/grub.d/00_user
            owner: root
            group: root
            mode: '0755'
            content: |
                cat <<EOF
                set superusers="admin"
                password_pbkdf2 admin grub.pbkdf2.sha512.10000.XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                EOF

      - name: "1.4.1 | PATCH | Ensure bootloader password is set | Allow unrestricted boot for normal users"
        ansible.builtin.lineinfile:
            path: /etc/grub.d/10_linux
            regexp: '(^CLASS="--class gnu-linux --class gnu --class os).*"$'
            line: '\g<1> --unrestricted"'
            backrefs: true
            create: false

      - name: "1.4.1 | PATCH | Ensure bootloader password is set | Update GRUB configuration"
        ansible.builtin.command: update-grub
        register: grub_update
        changed_when: grub_update.rc == 0
  when: ansible_os_family == "Debian"
  tags:
      - level1-server
      - level1-workstation
      - automated
      - patch
      - rule_1.4.1
      - grub
      - password

- name: "1.4.2 | PATCH | Ensure permissions on bootloader config are configured"
  block:
      - name: "1.4.2 | AUDIT | Check if GRUB configuration exists"
        ansible.builtin.stat:
            path: /boot/grub/grub.cfg
        register: grub_cfg_status

      - name: "1.4.2 | PATCH | Set secure permissions on GRUB configuration"
        ansible.builtin.file:
            path: /boot/grub/grub.cfg
            owner: root
            group: root
            mode: '0600'
        when: grub_cfg_status.stat.exists
  when: ansible_os_family == "Debian"
  tags:
      - level1-server
      - level1-workstation
      - automated
      - patch
      - rule_1.4.2
      - grub
      - permissions

- name: "1.4.3 | PATCH | Ensure authentication required for single user mode"
  block:
      - name: "1.4.3 | PATCH | Copy rescue.service if missing"
        ansible.builtin.copy:
            src: /lib/systemd/system/rescue.service
            dest: /etc/systemd/system/rescue.service
            owner: root
            group: root
            mode: '0644'
            remote_src: true
            force: false

      - name: "1.4.3 | PATCH | Ensure single-user mode requires authentication"
        ansible.builtin.lineinfile:
            path: /etc/systemd/system/rescue.service
            regexp: '^ExecStart='
            line: 'ExecStart=-/bin/sh -c "/sbin/sulogin; /bin/systemctl --fail --no-block default"'
            create: false

      - name: "1.4.3 | PATCH | Copy emergency.service if missing"
        ansible.builtin.copy:
            src: /lib/systemd/system/emergency.service
            dest: /etc/systemd/system/emergency.service
            owner: root
            group: root
            mode: '0644'
            remote_src: true
            force: false

      - name: "1.4.3 | PATCH | Ensure emergency mode requires authentication"
        ansible.builtin.lineinfile:
            path: /etc/systemd/system/emergency.service
            regexp: '^ExecStart='
            line: 'ExecStart=-/bin/sh -c "/sbin/sulogin; /bin/systemctl --fail --no-block default"'
            create: false

      - name: "1.4.3 | PATCH | Reload systemd daemon to apply changes"
        ansible.builtin.command: systemctl daemon-reload
        changed_when: false
  when: ansible_os_family == "Debian"
  tags:
      - level1-server
      - level1-workstation
      - automated
      - patch
      - rule_1.4.3
      - grub
      - sulogin
      - authentication


- name: "1.4.4 | PATCH | Ensure prelink is not installed"
  block:
      - name: "1.4.4 | AUDIT | Check if prelink is installed"
        ansible.builtin.shell: dpkg-query -W -f='${binary:Package}\t${db:Status-Status}\n' prelink 2>/dev/null || true
        changed_when: false
        failed_when: false
        register: prelink_check

      - name: "1.4.4 | PATCH | Display current prelink installation status"
        ansible.builtin.debug:
            msg:
                - "Prelink package status:"
                - "{{ prelink_check.stdout_lines | default(['Package not found']) }}"

      - name: "1.4.4 | PATCH | Restore binaries to normal if prelink is installed"
        ansible.builtin.shell: prelink -ua
        args:
            warn: false
        when: "'installed' in prelink_check.stdout"
        changed_when: false
        failed_when: false

      - name: "1.4.4 | PATCH | Ensure prelink package is removed"
        ansible.builtin.package:
            name: prelink
            state: absent
  when: ansible_os_family == "Debian"
  tags:
      - level1-server
      - level1-workstation
      - automated
      - patch
      - rule_1.4.4
      - prelink
      - packages
      - security

- name: "1.4.5 | PATCH | Ensure maxlogins is 10 or less"
  block:
      - name: "1.4.5 | AUDIT | Check current maxlogins setting in limits.conf"
        ansible.builtin.shell: grep -E '^\*.*hard.*maxlogins' /etc/security/limits.conf || true
        changed_when: false
        failed_when: false
        register: maxlogins_check

      - name: "1.4.5 | PATCH | Display current maxlogins configuration"
        ansible.builtin.debug:
            msg:
                - "Current maxlogins configuration in /etc/security/limits.conf:"
                - "{{ maxlogins_check.stdout_lines | default(['No configuration found']) }}"

      - name: "1.4.5 | PATCH | Ensure maxlogins is configured to 10 or less"
        ansible.builtin.lineinfile:
            path: /etc/security/limits.conf
            regexp: '^\*.*hard.*maxlogins'
            line: '* hard maxlogins 10'
            create: false
            insertafter: BOF
  when: ansible_os_family == "Debian"
  tags:
      - stig
      - level1-server
      - level1-workstation
      - automated
      - patch
      - rule_1.4.5
      - pam
      - limits
      - logins

- name: "1.4.6 | PATCH | Ensure Automatic Error Reporting is not enabled"
  block:
      - name: "1.4.6 | AUDIT | Check if apport package is installed"
        ansible.builtin.shell: dpkg-query -s apport 2>/dev/null | grep -i 'Status' || true
        changed_when: false
        failed_when: false
        register: apport_status

      - name: "1.4.6 | PATCH | Display apport package status"
        ansible.builtin.debug:
            msg:
                - "Apport package status:"
                - "{{ apport_status.stdout_lines | default(['Apport not installed']) }}"

      - name: "1.4.6 | PATCH | Disable apport in /etc/default/apport if present"
        ansible.builtin.lineinfile:
            path: /etc/default/apport
            regexp: '^\s*enabled\s*='
            line: 'enabled=0'
            create: false
        when: "'installed' in apport_status.stdout"

      - name: "1.4.6 | PATCH | Stop and disable apport service"
        ansible.builtin.systemd:
            name: apport.service
            state: stopped
            enabled: false
        when: "'installed' in apport_status.stdout"

      - name: "1.4.6 | PATCH | Ensure apport package is removed"
        ansible.builtin.package:
            name: apport
            state: absent
  when: ansible_os_family == "Debian"
  tags:
      - level1-server
      - level1-workstation
      - automated
      - patch
      - rule_1.4.6
      - apport
      - error-reporting
      - services
      - privacy

- name: "1.4.7 | PATCH | Ensure kdump service is not enabled"
  block:
    - name: "1.4.7 | AUDIT | Check if kdump unit exists"
      ansible.builtin.shell: |
        systemctl list-unit-files --type=service | awk '{print $1}' | grep -Fxq kdump.service
      register: kdump_unit
      changed_when: false
      failed_when: false

    - name: "1.4.7 | AUDIT | Check if kdump service is active"
      ansible.builtin.shell: systemctl is-active kdump.service
      register: kdump_status
      changed_when: false
      failed_when: false
      when: kdump_unit.rc == 0 

    - name: "1.4.7 | PATCH | Display current kdump service status"
      ansible.builtin.debug:
        msg:
          - "Current kdump.service status:"
          - "{{ (kdump_status.stdout | default('service-missing')) if kdump_unit.rc == 0 else 'service-missing' }}"

    - name: "1.4.7 | PATCH | Disable and stop kdump service if active"
      ansible.builtin.systemd:
        name: kdump.service
        state: stopped
        enabled: false
      when:
        - kdump_unit.rc == 0      
        - kdump_status.rc == 0        

    - name: "1.4.7 | PATCH | Mask kdump service to prevent accidental reactivation"
      ansible.builtin.systemd:
        name: kdump.service
        masked: true
      when: kdump_unit.rc == 0   
  when: ansible_os_family == "Debian"
  tags:
    - stig
    - level1-server
    - level1-workstation
    - automated
    - patch
    - rule_1.4.7
    - kdump
    - services
    - security

- name: "1.4.8 | PATCH | Ensure core dumps are restricted"
  block:
      - name: "1.4.8 | PATCH | Ensure hard limit for core dumps is set to 0"
        ansible.builtin.lineinfile:
            path: /etc/security/limits.conf
            regexp: '^\*.*hard.*core'
            line: '* hard core 0'
            create: false
            insertafter: EOF

      - name: "1.4.8 | PATCH | Ensure fs.suid_dumpable is set to 0 in sysctl configuration"
        ansible.posix.sysctl:
            name: fs.suid_dumpable
            value: '0'
            sysctl_set: true
            state: present
            reload: true

      - name: "1.4.8 | AUDIT | Check if systemd-coredump is installed"
        ansible.builtin.shell: systemctl is-enabled coredump.service 2>/dev/null || true
        changed_when: false
        failed_when: false
        register: coredump_status

      - name: "1.4.8 | PATCH | Restrict systemd-coredump if installed"
        block:
            - name: "1.4.8 | PATCH | Configure /etc/systemd/coredump.conf"
              ansible.builtin.blockinfile:
                  path: /etc/systemd/coredump.conf
                  create: true
                  owner: root
                  group: root
                  mode: '0644'
                  block: |
                      [Coredump]
                      Storage=none
                      ProcessSizeMax=0

            - name: "1.4.8 | PATCH | Reload systemd daemon"
              ansible.builtin.command: systemctl daemon-reload
              changed_when: false
        when: "'enabled' in coredump_status.stdout or 'disabled' in coredump_status.stdout or 'masked' in coredump_status.stdout"
  when: ansible_os_family == "Debian"
  tags:
      - level1-server
      - level1-workstation
      - automated
      - patch
      - rule_1.4.8
      - core
      - dumps
      - sysctl
      - limits

- name: "1.4.9 | PATCH | Ensure the Ctrl-Alt-Delete key sequence is disabled"
  block:
      - name: "1.4.9 | AUDIT | Check status of ctrl-alt-del.target"
        ansible.builtin.shell: systemctl is-enabled ctrl-alt-del.target 2>/dev/null || true
        changed_when: false
        failed_when: false
        register: ctrl_alt_del_status

      - name: "1.4.9 | PATCH | Display current Ctrl-Alt-Delete target status"
        ansible.builtin.debug:
            msg:
                - "Current ctrl-alt-del.target status:"
                - "{{ ctrl_alt_del_status.stdout | default('Not present') }}"

      - name: "1.4.9 | PATCH | Mask ctrl-alt-del.target to disable reboot key sequence"
        ansible.builtin.systemd:
            name: ctrl-alt-del.target
            masked: true

      - name: "1.4.9 | PATCH | Reload systemd daemon after masking ctrl-alt-del.target"
        ansible.builtin.command: systemctl daemon-reload
        changed_when: false
  when: ansible_os_family == "Debian"
  tags:
      - stig
      - level1-server
      - level1-workstation
      - automated
      - patch
      - rule_1.4.9
      - ctrl-alt-del
      - reboot
      - systemd


- name: "1.4.10 | PATCH | Ensure dmesg_restrict is enabled"
  block:
      - name: "1.4.10 | PATCH | Ensure kernel.dmesg_restrict is set to 1 in sysctl configuration"
        ansible.posix.sysctl:
            name: kernel.dmesg_restrict
            value: '1'
            sysctl_set: true
            state: present
            reload: true

      - name: "1.4.10 | AUDIT | Verify current kernel.dmesg_restrict value"
        ansible.builtin.shell: sysctl kernel.dmesg_restrict | awk '{print $3}'
        changed_when: false
        failed_when: false
        register: dmesg_restrict_status

      - name: "1.4.10 | PATCH | Display current dmesg_restrict status"
        ansible.builtin.debug:
            msg:
                - "Current kernel.dmesg_restrict value: {{ dmesg_restrict_status.stdout | default('Unknown') }}"
                - "Expected value: 1 (restricts non-root users from accessing kernel logs)"
  when: ansible_os_family == "Debian"
  tags:
      - stig
      - level1-server
      - level1-workstation
      - automated
      - patch
      - rule_1.4.10
      - sysctl
      - kernel
      - dmesg
      - security

- name: "1.6.1 | PATCH | Ensure message of the day is configured properly"
  block:
      - name: "1.6.1 | AUDIT | Check /etc/motd for OS version or release information"
        ansible.builtin.shell: >
          grep -Eis "(\\\v|\\\r|\\\m|\\\s|$(grep '^ID=' /etc/os-release | cut -d= -f2 | sed -e 's/\"//g'))" /etc/motd || true
        changed_when: false
        failed_when: false
        register: motd_check

      - name: "1.6.1 | PATCH | Display current /etc/motd findings"
        ansible.builtin.debug:
            msg:
                - "Current /etc/motd contains potentially sensitive or system-identifying information:"
                - "{{ motd_check.stdout_lines | default(['No OS-related strings found']) }}"

      - name: "1.6.1 | PATCH | Configure compliant Message of the Day"
        ansible.builtin.copy:
            dest: /etc/motd
            owner: root
            group: root
            mode: '0644'
            content: |
                ******************************************************************
                * WARNING: Authorized use only.                                 *
                * All activity may be monitored and reported.                   *
                * Disconnect immediately if you are not an authorized user.     *
                ******************************************************************
  when: ansible_os_family == "Debian"
  tags:
      - level1-server
      - level1-workstation
      - automated
      - patch
      - rule_1.6.1
      - motd
      - banner
      - login
      - security

- name: "1.6.2 | PATCH | Ensure local login warning banner is configured properly"
  block:
      - name: "1.6.2 | AUDIT | Check /etc/issue for OS version or release information"
        ansible.builtin.shell: >
          grep -Eis "(\\\v|\\\r|\\\m|\\\s|$(grep '^ID=' /etc/os-release | cut -d= -f2 | sed -e 's/\"//g'))" /etc/issue || true
        changed_when: false
        failed_when: false
        register: issue_check

      - name: "1.6.2 | PATCH | Display current /etc/issue findings"
        ansible.builtin.debug:
            msg:
                - "Current /etc/issue contains potentially sensitive or system-identifying information:"
                - "{{ issue_check.stdout_lines | default(['No OS-related strings found']) }}"

      - name: "1.6.2 | PATCH | Configure compliant local login warning banner"
        ansible.builtin.copy:
            dest: /etc/issue
            owner: root
            group: root
            mode: '0644'
            content: |
                ******************************************************************
                * WARNING: Authorized access only.                               *
                * All activities on this system are monitored and recorded.      *
                * Disconnect immediately if you are not an authorized user.     *
                ******************************************************************
  when: ansible_os_family == "Debian"
  tags:
      - level1-server
      - level1-workstation
      - automated
      - patch
      - rule_1.6.2
      - issue
      - banner
      - login
      - security

- name: "1.6.3 | PATCH | Ensure remote login warning banner is configured properly"
  block:
      - name: "1.6.3 | AUDIT | Check /etc/issue.net for OS version or release information"
        ansible.builtin.shell: >
          grep -Eis "(\\\v|\\\r|\\\m|\\\s|$(grep '^ID=' /etc/os-release | cut -d= -f2 | sed -e 's/\"//g'))" /etc/issue.net || true
        changed_when: false
        failed_when: false
        register: issue_net_check

      - name: "1.6.3 | PATCH | Display current /etc/issue.net findings"
        ansible.builtin.debug:
            msg:
                - "Current /etc/issue.net contains potentially sensitive or system-identifying information:"
                - "{{ issue_net_check.stdout_lines | default(['No OS-related strings found']) }}"

      - name: "1.6.3 | PATCH | Configure compliant remote login warning banner"
        ansible.builtin.copy:
            dest: /etc/issue.net
            owner: root
            group: root
            mode: '0644'
            content: |
                ******************************************************************
                * WARNING: Authorized access only.                               *
                * Remote connections are monitored and recorded.                 *
                * Disconnect immediately if you are not an authorized user.     *
                ******************************************************************
  when: ansible_os_family == "Debian"
  tags:
      - level1-server
      - level1-workstation
      - automated
      - patch
      - rule_1.6.3
      - issue.net
      - banner
      - ssh
      - login
      - security

- name: "1.6.4 | PATCH | Ensure permissions on /etc/motd are configured"
  block:
      - name: "1.6.4 | AUDIT | Check if /etc/motd exists"
        ansible.builtin.stat:
            path: /etc/motd
        register: motd_status

      - name: "1.6.4 | PATCH | Set ownership and permissions on /etc/motd if it exists"
        ansible.builtin.file:
            path: /etc/motd
            owner: root
            group: root
            mode: '0644'
        when: motd_status.stat.exists

      - name: "1.6.4 | AUDIT | Display message if /etc/motd does not exist"
        ansible.builtin.debug:
            msg: "/etc/motd file does not exist — no action required."
        when: not motd_status.stat.exists
  when: ansible_os_family == "Debian"
  tags:
      - level1-server
      - level1-workstation
      - automated
      - patch
      - rule_1.6.4
      - motd
      - permissions
      - security
